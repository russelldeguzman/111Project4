# Fill in your name, student ID, and email address in this file.
# If you are working in a team, fill out the information for both team 
# members.

# SUBMIT THE LAB ONLY ONCE (from only one partner). This file will be
# automatically parsed in order to give both team members credit for the
# lab.

# You need to fill in the EXERCISE sections describing your solutions
# for Tasks 1, 2, and 3, as well as write the corresponding code.
# If you did one or more extra credit problems, indicate which one in the
# appropriate section below (remove the # sign first). If you have any other
# information you'd like us to know, please add it at the end of the file.

# Partner 1
Name: David Yang
Student ID: 404330995
Email: dayy@linux.ucla.edu

# Partner 2 (if you're working in a team)
Name: Russell Deguzman
Student ID: 
Email: 

# EXERCISE 1: What method you used to make your peer download and upload
#    files in parallel?  (~1-3 sentences)

We first fork off a new process for each download and wait for all the
downloads to finish before moving onto the uploads. We could probably
mix the two in some clever way, but this is guaranteed to prevent problems
where we could be trying to upload a file that we are currently
downloading. We then begin listening for upload requests, and fork off a
new process if there are currently less than a predetermined number (five)
of uploads already happening. If we do, we increment the number of
currently running processes. If we don't we tell the user that we rejected
an upload request. This should prevent denial of service, if that's a
thing that the bad tracker will attempt on us. We also clean up finished
processes for upload requests every time we receive an upload request.

# EXERCISE 2A: What conditions did you find and fix that would have
#    triggered a buffer overrun bug?  (~1-3 sentences each)



# EXERCISE 2B: What other robustness problems did you fix?  (~1-3 sentences
#    each)

We do some string checking on upload requests to make sure that only files
inside the current directory and subdirectories are requested. This means
dying if we find a ../, ~/ or a / at the front of the requested file path.
We also need to die if there are more /../ than there are /[directory]/ in
a file path, as that will also lead to serving files we shouldn't be
serving.


# Add any other information you'd like us to know below this line.
